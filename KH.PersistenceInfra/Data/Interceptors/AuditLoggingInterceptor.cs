using KH.BuildingBlocks.Apis.Entities;
using KH.BuildingBlocks.Auth.User;
using KH.BuildingBlocks.Common.Attributes;
using Microsoft.AspNetCore.Http;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;

namespace KH.PersistenceInfra.Data.Interceptors;
public class AuditLoggingInterceptor : SaveChangesInterceptor
{
  private readonly IHttpContextAccessor _httpContextAccessor;
  private readonly ICurrentUserService _currentUserService;
  private readonly IServiceProvider _serviceProvider;

  public AuditLoggingInterceptor(
      IHttpContextAccessor httpContextAccessor,
      ICurrentUserService currentUserService,
      IServiceProvider serviceProvider)
  {
    _httpContextAccessor = httpContextAccessor;
    _currentUserService = currentUserService;
    _serviceProvider = serviceProvider;
  }

  public override async ValueTask<InterceptionResult<int>> SavingChangesAsync(
      DbContextEventData eventData,
      InterceptionResult<int> result,
      CancellationToken cancellationToken = default)
  {
    var context = eventData.Context;
    if (context == null) return result;

    var userId = _currentUserService.UserId;
    var auditEntries = OnBeforeSaveChanges(context, userId);

    context.AddRange(auditEntries.Select(ae => ae.ToAudit()));
    return result;
  }

  public override async ValueTask<int> SavedChangesAsync(
      SaveChangesCompletedEventData eventData,
      int result,
      CancellationToken cancellationToken = default)
  {
    var context = eventData.Context;
    if (context == null) return result;

    // Collect the audit entries to be saved after the main transaction
    var auditEntries = OnAfterSaveChanges(context);

    // Ensure you're saving audit entries separately to avoid looping
    if (auditEntries.Any())
    {
      var auditContext = (AppDbContext)_serviceProvider.GetService(typeof(AppDbContext));
      auditContext.AddRange(auditEntries.Select(ae => ae.ToAudit()));
      await auditContext.SaveChangesAsync(cancellationToken); // Save audit logs in a separate context
    }

    return result;
  }


  private List<AuditEntry> OnBeforeSaveChanges(DbContext context, string userId)
  {
    var auditEntries = new List<AuditEntry>();
    foreach (var entry in context.ChangeTracker.Entries())
    {
      // Skip audit for certain entities or unchanged/detached entities Skip entities with [NoAudit] attribute
      var entityType = entry.Entity.GetType();
      if (entityType.GetCustomAttribute<NoAuditAttribute>() != null
        || entry.Entity is Audit
        || entry.State == EntityState.Detached
        || entry.State == EntityState.Unchanged)
        continue;

      var auditEntry = new AuditEntry(entry)
      {
        TableName = entry.Entity.GetType().Name,
        UserId = userId,
        CorrelationId = _httpContextAccessor.HttpContext?.TraceIdentifier ?? "internal-process"
      };

      foreach (var property in entry.Properties)
      {
        string propertyName = property.Metadata.Name;
        if (property.IsTemporary)
        {
          // Value will be generated by the database, get the value after saving
          auditEntry.TemporaryProperties.Add(property);
          continue;
        }

        if (property.Metadata.IsPrimaryKey())
        {
          auditEntry.KeyValues[propertyName] = property.CurrentValue;
          continue;
        }

        switch (entry.State)
        {
          case EntityState.Added:
            auditEntry.NewValues[propertyName] = property.CurrentValue;
            break;

          case EntityState.Deleted:
            auditEntry.OldValues[propertyName] = property.OriginalValue;
            break;

          case EntityState.Modified:
            if (property.IsModified)
            {
              auditEntry.OldValues[propertyName] = property.OriginalValue;
              auditEntry.NewValues[propertyName] = property.CurrentValue;
            }
            break;
        }
      }

      auditEntries.Add(auditEntry);
    }

    // Save audit entries that have temporary properties
    foreach (var auditEntry in auditEntries.Where(ae => !ae.HasTemporaryProperties))
    {
      context.Add(auditEntry.ToAudit());
    }

    return auditEntries.Where(ae => ae.HasTemporaryProperties).ToList();
  }

  private List<AuditEntry> OnAfterSaveChanges(DbContext context)
  {
    var auditEntries = new List<AuditEntry>();
    foreach (var entry in context.ChangeTracker.Entries())
    {
      // Skip audit for certain entities or unchanged/detached entities Skip entities with [NoAudit] attribute
      var entityType = entry.Entity.GetType();
      if (entityType.GetCustomAttribute<NoAuditAttribute>() != null
        || entry.Entity is Audit
        || entry.State == EntityState.Detached
        || entry.State == EntityState.Unchanged)
        continue;

      var auditEntry = new AuditEntry(entry)
      {
        TableName = entry.Entity.GetType().Name,
        UserId = _currentUserService.UserId
      };

      foreach (var property in entry.Properties)
      {
        string propertyName = property.Metadata.Name;
        if (property.IsTemporary)
        {
          auditEntry.KeyValues[propertyName] = property.CurrentValue;
        }
      }

      auditEntries.Add(auditEntry);
    }

    return auditEntries;
  }
}
